% LaTeX template adapted from: https://www.overleaf.com/latex/templates/simple-math-homework-template/tbszsswsndrz
\documentclass[landscape,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[]{amsthm} %lets us use \begin{proof}
\usepackage[]{amssymb} %gives us the character \varnothing
\usepackage{amsmath} %for equations
\usepackage[]{listings} %for code blocks
\usepackage{graphicx} %for diagrams
\usepackage{fancyhdr} %for headers
\usepackage[letterpaper, margin=0.5in]{geometry}
\usepackage{tikz} % for drawings
\usepackage{multicol}
\usepackage{ifthen}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{color}
\usepackage{wrapfig}
\usepackage{booktabs}
\setlist{nolistsep}
\setlist[itemize]{leftmargin=0.5pc,itemsep=0.25em}
\usetikzlibrary{arrows.meta,shapes.arrows,chains,decorations.pathreplacing}
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
            {-1ex plus -.5ex minus -.2ex}%
            {0.5ex plus .2ex}%x
            {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
            {-1explus -.5ex minus -.2ex}%
            {0.5ex plus .2ex}%
            {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
            {-1ex plus -.5ex minus -.2ex}%
            {1ex plus .2ex}%
            {\normalfont\small\bfseries}}
\makeatother
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}


\lstset{frame=single,
  language=c,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\small\ttfamily},
  numbers=none,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\newcommand{\code}{\lstinline}
\graphicspath{}
\pagestyle{empty}
\ifthenelse{\lengthtest { \paperwidth = 11in}}
{ \geometry{top=.5in,left=.5in,right=.5in,bottom=.5in} }
{\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
{\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
{\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
}
\setlength{\parindent}{0em}
\setlength{\parskip}{-0.25em}

\begin{document}
    \footnotesize
    \begin{multicols}{3}
    \setlength{\premulticols}{1pt}
    \setlength{\postmulticols}{1pt}
    \setlength{\multicolsep}{1pt}
    \setlength{\columnsep}{2pt}
    Pete Wilcox\\
    CruzID: pcwilcox

    \subparagraph*{Tuples and Relations:}
    \begin{itemize}
        \item \emph{Tuple:} a $k$\emph{-tuple} is an ordered sequence of $k$ values
        \item If $D_1, D_2, \ldots, D_k$ are sets of elements then the cartesian product $D_1 \times
        D_2 \times \ldots D_k$ is the set of all $k$-tuples $(d_1, d_2, \ldots, d_k)$ such that
        $\forall 1 \leq i \leq k:\ d_i \in D_i$
        \item \emph{Relation:}
        \begin{itemize}
            \item A $k$\emph{-ary relation} is a subset of $D_1 \times D_2 \times \ldots D_k$ where
            each $D_i$ is a set of elements
            \item $D_i$ is the \emph{domain (or datatype)} of the $i^{th}$ column of the relation
            \item Domains may be enumerated $\{``AMS'', ``CMPS'', ``TIM''\}$ or may be of standard
            types 
        \end{itemize}
        \item An \emph{attribute} is the name of a column in a relation
        \item A \emph{relation schema} $R$ is a set $\{A_1, \ldots, A_k\}$ of attributes written
        $R(A_1, \ldots, A_k)$, where $A_i$ is the name of the $i^{th}$ column. 
        \item A \emph{relation database schema} or \emph{database schema} is a set of relation
        schemas with disjoint relation names.
    \end{itemize}
    \subparagraph*{SQL Primitives:}
    \begin{itemize}
        \item \code{CHAR(n)}: fixed-length string of up to $n$ characters (blank-padded with
        trailing spaces)
        \item \code{VARCHAR(n)}: also a string of up to $n$ characters
        \item \code{BIT(n)}: padded on the right with \code{0}s.
        \item \code{BIG VARYING(n)}: works like \code{VARCHAR}
        \item \code{BOOLEAN}: true, false, unknown
        \item \code{INT} or \code{INTEGER}: works like in C
        \item \code{SHORTINT}: works like \code{short int}
        \item \code{DECIMAL(n, d)}, \code{NUMERIC(n, d)}: total of $n$ digits, $d$ of them to the
        right of the decimal point
        \item \code{FLOAT(p)}, \code{FLOAT}, \code{REAL}
        \item \code{DOUBLE PRECISION}: analagous to \code{double} in c
        \item \code{DATE}, \code{TIME}, \code{TIMESTAMP}, \code{INTERVAL}: constants are character
        strings of specific form e.g. \code{DATE `2017-09-13'}
        \begin{itemize}
            \item Subtracting one \code{TIME} from another results in an \code{INTERVAL}
            \item Taking a \code{TIME} and adding an \code{INTERVAL} results in a \code{TIME}
            \item Similarly for \code{TIMESTAMP} and \code{DATE}
        \end{itemize}
    \end{itemize}
    \subparagraph*{Tables:} 
    \begin{itemize}
    \item A \emph{key constraint} or \emph{key} of a relation schema $R$ is a subset $K$ of the
        attributes of $R$ such that:
        \begin{enumerate}
            \item For every instance $r$ of $R$, every two distinct tuples of $r$ must differ in
            their values of $K \iff$ there can't be two different tuples that have the same value
            for key $K$
            \item No proper subset of $K$ has the above property
        \end{enumerate}
        \item A \emph{superkey} is a set of attributes of $R$ that includes a key of $R$
        \item \code{CREATE TABLE R(A, B, C, PRIMARY KEY(A))}:
        \begin{enumerate}
        \item None of the tuples in \code{R} can have null \code{A} values
        \item Rows are uniquely identified by their \code{A} values
        \item There can be at most one primary key for a table
        \end{enumerate}
        \item \code{CREATE TABLE S(D, E, F, UNIQUE(D))}:
        \begin{enumerate}
            \item Rows in \code{S} can contain null \code{D} values
            \item Rows with \emph{non-null} \code{D} values are uniquely identified by their \code{D} values
            \item There can be multiple unique constraints in addition to a primary key
        \end{enumerate}
        \item \code{CREATE TABLE T(G NOT NULL, H DEFAULT `foo')}:
        \begin{enumerate}
            \item If no default value is specified and no value is entered then the value will be \code{NULL}
            \item \code{NOT NULL} prevents a column from having null values
            \item If a default value is specified and no value is entered then the value will be the
            default
        \end{enumerate}
    \end{itemize}
    \subparagraph*{Queries:}
    \begin{itemize}
        \item Basic form: \\
\code{SELECT [DISTINCT] c1, c2, ..., cm} \\
\code{FROM R1, R2, ..., Rn} \\
\code{[WHERE condition]}
    \item \code{SELECT}:
    \begin{itemize}
        \item Projection: \code{SELECT title, year} - only a subset of attributes from the
        relation(s) in the \code{FROM} clause is selected
        \item \code{DISTINCT}: Removes duplicate tuples from result
        \item Aliasing: \code{SELECT title AS name} - rename the attributes in the result
        \item Expressions are allowed in the \code{SELECT} clause. Ex: \code{SELECT title AS name, length * 60 AS durationInSeconds}
        \item Constants can also be included: \code{SELECT title AS name, length * 60 AS durationInSeconds, `seconds' AS inSeconds}
    \end{itemize}
        \item \code{WHERE}:
        \begin{itemize}
            \item Comparison operators: \code{=}, \code{<>}, \code{<}, \code{>}, \code{<=}, \code{>=}
            \item Logical connectives: \code{AND}, \code{OR}, \code{NOT}
            \item Arithmetic expressions: \code{+}, \code{-}, \code{*}, \code{/}, etc
            \item In general the \code{WHERE} clause is a boolean expression where each condition is
            of the form \emph{expression op expression}
        \end{itemize}
        \item Pattern matching with the \code{LIKE} operator:
        \begin{itemize}
            \item $s$ \code{LIKE} $p$, $s$ \code{NOT LIKE} $p$
            \item $s$ is a string, $p$ is a pattern
            \item `\code{\%}' stands for \code{0} or more arbitrary characters
            \item `\code{_}' stands for exactly one arbitrary character
            \item Matching quotes: \code{WHERE x LIKE ''''} matches one 
            \item Matching quotes: \code{WHERE x LIKE ''''''} matches two 
            \item Matching \code{\%} or \code{_}: \code{WHERE x LIKE `!\%\%!' ESCAPE '!'} where
            \code{!} can be any character
        \end{itemize}
        \item \code{DATE} and \code{TIME} and \code{TIMESTAMP}
        \begin{itemize}
            \item Separate data types
            \item Constants are character strings of the form: \\
\code{DATE '2015-01-13'} \\
\code{TIME '16:45:33'} \\
\code{TIMESTAMP '2015-01-13 16:45:33'} \\
            \item \code{DATE}, \code{TIME}, \code{TIMESTAMP} can be compared using ordinary
            comparison operators e.g. \code{WHERE ReleaseDate <= DATE '1990-06-19'}
\end{itemize}
        \item If \code{Salary} is \code{NULL} then the following will be \code{UNKNOWN}:
        \begin{itemize}
            \item \code{Salary = 10}
            \item \code{Salary <> 10}
            \item \code{90 > Salary OR 90 <= Salary}
            \item \code{Salary = NULL}
            \item \code{Salary <> NULL}
            \end{itemize}
            \item Use of \code{IS NULL} and \code{IS NOT NULL}:
            \begin{itemize}
                \item \code{Salary IS NULL} will be true if \code{SALARY} \emph{is} \code{NULL},
                false otherwise
                \item \code{Salary IS NOT NULL} will be true if \code{SALARY} \emph{is not}
                \code{NULL}, false otherwise
            \end{itemize}
        \item Ordering the result:
        \begin{itemize}
            \item \code{ORDER BY} presents the result in a sorted order
            \item By default the result will be ordered in ascending order \code{ASC}
            \item For descending order on an attribute you write \code{DESC} in the list of attributes
        \end{itemize}
        \item Multiple relations in \code{FROM} clause: for every tuple $t_1 \in R_1, t_2 \in R_2,
        \ldots, t_n from R_n$ if $t_1, \ldots, t_n$ satisfy \emph{condition} then add the resulting
        tuple that consists of $c_1, c_2, \ldots, c_m$ components of $t$ into the result
    \end{itemize}
    \subparagraph*{Joins:} With relations \code{R(A,B,C)} and \code{S(C,D,E)}
    \begin{itemize}
        \item \code{R JOIN S ON R.B=S.D AND R.A=S.E}:
        \begin{itemize}
            \item Selects only tuples from \code{R} and \code{S} where \code{R.B=S.D} and \code{R.A=S.E}
            \item Schema of the resulting relation: \code{(R.A, R.B, R.C, S.C, S.D, S.E)}
            \item Equivalent to: \\
            \code{SELECT *} \\
            \code{FROM R, S} \\
            \code{WHERE R.B=S.D AND R.A=S.E;}
        \end{itemize}
        \item \code{R CROSS JOIN S}:
        \begin{itemize}
            \item Product of the two relations \code{R} and \code{S}
            \item Schema of the resulting relation: \code{(R.A, R.B, R.C, S.C, S.D, S.E)}
            \item Equivalent to: \\
            \code{SELECT *} \\
            \code{FROM R, S;}
        \end{itemize}
        \item \code{R NATURAL JOIN S}:
        \begin{itemize}
            \item Schema of the resulting relation: \code{(A, B, C, D, E)}
            \item Equivalent to: \\
            \code{SELECT R.A, R.B, R.C, S.D, S.E} \\
            \code{FROM R, S} \\
            \code{WHERE R.C = S.C}
        \end{itemize}
    \end{itemize}
    \subparagraph*{Set and Bag Operations:} \code{R(A,B,C), S(A,B,C)}
    \begin{itemize}
        \item \code{UNION}: Set union
        \begin{itemize}
            \item Input to union must be \emph{union-compatible}: \code{R} and \code{S} must have
            attributes of the same type, in the same order
            \item Output of the union has the same schema as \code{R} or \code{S}
            \item Meaning: Output consists of the \emph{set} of all tuples from \code{R} and from \code{S}
            \item Could (should?) have been called \code{UNION DISTINCT} \\
            \code{(SELECT * FROM R)} \\
            \code{UNION} \\
            \code{(SELECT * FROM S)} \\
        \end{itemize}
        \item \code{UNION ALL}: Bag union
        \begin{itemize}
            \item Input must be \emph{union-compatible}
            \item Output has the same schema as \code{R} or \code{S}
            \item Output consists of the collection of all tuples from \code{R} and from \code{S} \emph{including duplicates}.
            \item Attributes/column names may be different - \code{R}'s are used
        \end{itemize}
        \item \code{INTERSECT}, \code{INTERSECT ALL}: set/bag intersection
        \begin{itemize}
            \item Input must be union-compatible.
            \item $Query_1$ \code{INTERSECT} $Query_2$ 
            \item $Query_1$ \code{INTERSECT ALL} $Query_2$
            \item Find all tuples that are in the results of both $Query_1$ and $Query_2$.
            \item \code{INTERSECT} is distinct. \code{INTERSECT ALL} reports duplicates.
        \end{itemize}
        \item \code{EXCEPT}, \code{EXCEPT ALL}: set difference, bag difference
        \begin{itemize}
            \item Must be union-compatible
            \item $Query_1$ \code{EXCEPT} $Query_2$
            \item $Query_1$ \code{EXCEPT ALL} $Query_2$
            \item Find all tuples that are in the result of $Query_1$ and not in the result of $Query_2$
            \item \code{EXCEPT} is distinct, \code{EXCEPT ALL} is not
        \end{itemize}
        \item Order of operations: \code{INTERSECT} has higher precedence than \code{UNION} and \code{EXCEPT}.
    \end{itemize}
    \subparagraph*{Subqueries:}
    \begin{itemize}
        \item A query embedded in another query
        \item Can be used as a boolean or can return a constant or can return a relation
        \item \code{IN}, \code{NOT IN}: used to select from subquery that returns relation
        \item \code{WHERE} $A$ \code{< ANY}: checks that attribute $A$ is less than at least one of
        the answers returned by the subquery.
        \item \code{EXISTS}: Checks that subquery returns non-empty result. Also: \code{NOT EXISTS}
    \end{itemize}
    \subparagraph*{Aggregates and Grouping:}
    \begin{itemize}
    \item Basic SQL has 5 aggregation operators: \code{SUM}, \code{AVG}, \code{MIN}, \code{MAX}, \code{COUNT}
    \item Aggregation operators work on scalar values, except for \code{COUNT(*)} which counts the
    number of tuples
    \item \code{GROUP BY} clause follows the \code{WHERE} clause
    \begin{itemize}
        \item Let Result begin as an empty multiset of tuples
        \item For every tuple $t_1$ from $R_1$, $t_2$ from $R_2, \ldots, t_n$ from $R_n$: if $t_1,
        \ldots, t_n$ satisfy \emph{condition} then add the resulting tuple that consist of $c_1,
        c_2, \ldots, c_m$ of the $t_i$ into Result
        \item Group the tuples according to the grouping attributes - if \code{GROUP BY} is omitted,
        the entire table is one group
    \end{itemize}
    \item \code{NULL}s are ignored in any aggregation
    \begin{itemize}
        \item They do not contribute to the \code{SUM}, \code{AVG}, \code{COUNT}, \code{MIN},
        \code{MAX} of an attribute
        \item \code{COUNT(*)} = the number of tuples in a relation even if some columns are \code{NULL}
        \item \code{COUNT(A)} is the number of tuples with \emph{non-}\code{NULL} values for $A$
        \item \code{SUM}, \code{AVG}, \code{MIN}, \code{MAX} on an empty result (no tuples) is \code{NULL}
        \item \code{COUNT} of an empty result is \code{0}
        \item \code{GROUP BY} does \emph{not} ignore \code{NULL}
    \end{itemize}
    \item \code{HAVING} clause:
    \begin{itemize}
        \item Choose groups based on some aggregate property of the group itself
        \item Same attributes and aggregates that can appear in the \code{SELECT} can appear in the
        \code{HAVING} clause condition
        \item Can use \code{EVERY} to constrain \code{HAVING} to all tuples in the group e.g. \code{HAVING COUNT(*) > 1 AND EVERY (S.age <= 40)}
    \end{itemize}
\end{itemize}
\subparagraph*{Database Modification Statements:}
\begin{itemize}
    \item \code{INSERT INTO R(A1, ..., An) VALUES (v1, ..., vn)}: a tuple $(v_1, \ldots, v_n)$ is
    inserted into $R$ such that $A_i = v_i \forall i$ and default values (perhaps \code{NULL}) are
    entered for any missing attributes.
    \item \code{DELETE FROM R WHERE <condition>}: Deletes \emph{all} tuples such that the condition
    evaluates as true - if there is no \code{WHERE} clause it will delete all tuples in $R$
    \item \code{UPDATE R SET <new-value-assignments> WHERE <condition>}: Change the given attribute
    to the new value in every tuple in $R$ where the condition is true
    \item Semantics: database modifications are completely evaluated on the old state of the
    database producing a new state of the database
\end{itemize}
\subparagraph*{Transaction:}
\begin{itemize}
    \item Transactions provide ACID properties: atomicity, consistency, isolation, durability
    \item \code{START TRANSACTION} or \code{BEGIN TRANSACTION}: marks the beginning of a
    transaction, followed by one or more SQL statements
    \item \code{COMMIT}: Ends the transaction. All changes are durably written to the backing store
    and become visible to other transactions.
    \item \code{ROLLBACK}: Causes the transaction to abort or terminate. None of the changes are committed.
    \item \code{SET TRANSACTION READ ONLY}: 
    \begin{itemize}
        \item set \emph{before} the transaction begins, tells the SQL system that the next
        transaction is read-only
        \item SQL uses this to parallelize many read-only transactions
    \end{itemize}
    \item \code{SET TRANSACTION READ WRITE}:
    \begin{itemize}
        \item Tells SQL that the next transaction may write data in addition to read
        \item Default option if not specified, often not specified
    \end{itemize}
    \item Dirty Reads: \emph{Dirty data} refers to data that is written by a transaction but has not
    yet been committed by the transaction
    \item Isolation levels:
    \begin{itemize}
        \item \code{SET TRANSACTION READ WRITE ISOLATION LEVEL READ UNCOMMITTED}
        \item Default isolation level depends on system, most run with \code{READ COMMITTED} or \code{SNAPSHOT ISOLATION}
        \item \code{READ COMMITTED}: only clean(committed) reads but you might read data committed
        by other transactions
        \item \code{REPEATABLE READ}: repeated queries of a tuple during a transaction will retrieve
        the same value. Also, a second scan may return `phantoms' which are tuples newly inserted
        while the transaction is running.
        \item \code{SERIALIZABLE}: Can be replayed one by one.
    \end{itemize}
    
\end{itemize}
    \end{multicols}

\end{document}

